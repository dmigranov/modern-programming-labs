; This is the Calva evaluation results output window.
; TIPS: The keyboard shortcut `ctrl+alt+c o` shows and focuses this window
;   when connected to a REPL session.
; Please see https://calva.io/output/ for more info.
; Happy coding! ♥️

; Connecting ...
; Hooking up nREPL sessions...
; Connected session: clj
; TIPS: 
;   - You can edit the contents here. Use it as a REPL if you like.
;   - `alt+enter` evaluates the current top level form.
;   - `ctrl+enter` evaluates the current form.
;   - `alt+up` and `alt+down` traverse up and down the REPL command history
;      when the cursor is after the last contents at the prompt
;   - File URLs in stacktrace frames are peekable and clickable.
clj::user=> 
(defn generate-word-list
  [alphabet word n]
  (let [first-letter (get word 0)]) ;char
  (if (> n 1)
    (if (> (count alphabet) 0)
      (concat (str (first alphabet) word)
              (generate-word-list (rest alphabet) word (dec n)))
      (list))    ;then: взять words с n-1  и прибавить буковки слева справа
    list    ;else
    ))
#'clojure-first.core/generate-word-list
clj::clojure-first.core=> 
(defn traverse-list [alphabet words n]
  (if (> (count words) 0)
    (concat (generate-word-list alphabet (first words) n)
            (traverse-list alphabet (rest words) n))
    (list)))
#'clojure-first.core/traverse-list
clj::clojure-first.core=> 
(defn generate-atomic-words
  [alphabet]
  (if (> (count alphabet) 0)
    (cons (str (first alphabet)) (generate-atomic-words (rest alphabet)))
    (list)))
#'clojure-first.core/generate-atomic-words
clj::clojure-first.core=> 
(defn main-word-function
  [alphabet n]
  (traverse-list alphabet (generate-atomic-words alphabet) n)
  )


#'clojure-first.core/main-word-function
clj::clojure-first.core=> 
(defn main-word-function
  [alphabet n]
  (traverse-list alphabet (generate-atomic-words alphabet) n))
#'clojure-first.core/main-word-function
clj::clojure-first.core=> 
(main-word-function [\a \d \f] n)
; Syntax error compiling at (clojure-first/.calva/output-window/output.calva-repl:57:1).
clj::clojure-first.core=> 
(main-word-function [\a \d \f] 3)
; Error printing return value (IllegalArgumentException) at clojure.lang.RT/seqFrom (RT.java:557).
; Don't know how to create ISeq from: clojure.lang.PersistentList$Primordial
clj::clojure-first.core=> 
(main-word-function (\d \q) 3)
; Execution error (ClassCastException) at clojure-first.core/eval2146 (REPL:64).
; class java.lang.Character cannot be cast to class clojure.lang.IFn (java.lang.Character is in module java.base of loader 'bootstrap'; clojure.lang.IFn is in unnamed module of loader 'bootstrap')
clj::clojure-first.core=> 
(generate-atomic-words (\d \q))
; Execution error (ClassCastException) at clojure-first.core/eval2228 (REPL:68).
; class java.lang.Character cannot be cast to class clojure.lang.IFn (java.lang.Character is in module java.base of loader 'bootstrap'; clojure.lang.IFn is in unnamed module of loader 'bootstrap')
clj::clojure-first.core=> 
(str (first (\d \q)))
; Execution error (ClassCastException) at clojure-first.core/eval2360 (REPL:72).
; class java.lang.Character cannot be cast to class clojure.lang.IFn (java.lang.Character is in module java.base of loader 'bootstrap'; clojure.lang.IFn is in unnamed module of loader 'bootstrap')
clj::clojure-first.core=> 
first (\d \q)
; Execution error (ClassCastException) at clojure-first.core/eval2452 (REPL:76).
; class java.lang.Character cannot be cast to class clojure.lang.IFn (java.lang.Character is in module java.base of loader 'bootstrap'; clojure.lang.IFn is in unnamed module of loader 'bootstrap')
clj::clojure-first.core=> 
'(\d \q)
(\d \q)
clj::clojure-first.core=> 
(generate-atomic-words '(\d \q))
("d" "q")
clj::clojure-first.core=> 

; Execution error (ClassCastException) at clojure-first.core/eval2458 (REPL:84).
; class java.lang.String cannot be cast to class clojure.lang.IFn (java.lang.String is in module java.base of loader 'bootstrap'; clojure.lang.IFn is in unnamed module of loader 'bootstrap')
clj::clojure-first.core=> 
; Execution error (ClassCastException) at clojure-first.core/eval2460 (REPL:84).
; class java.lang.String cannot be cast to class clojure.lang.IFn (java.lang.String is in module java.base of loader 'bootstrap'; clojure.lang.IFn is in unnamed module of loader 'bootstrap')
clj::clojure-first.core=> 
; Execution error (ClassCastException) at clojure-first.core/eval2462 (REPL:84).
; class java.lang.String cannot be cast to class clojure.lang.IFn (java.lang.String is in module java.base of loader 'bootstrap'; clojure.lang.IFn is in unnamed module of loader 'bootstrap')
clj::clojure-first.core=> 
(+ 3 2)
5
clj::clojure-first.core=> 
(main-word-function '(\d \q) 3)
; Error printing return value (IllegalArgumentException) at clojure.lang.RT/seqFrom (RT.java:557).
; Don't know how to create ISeq from: clojure.lang.PersistentList$Primordial
clj::clojure-first.core=> 
(generate-word-list '(\f \s) "s" 1)
#object[clojure.lang.PersistentList$Primordial 0x6e134c9 "clojure.lang.PersistentList$Primordial@6e134c9"]
clj::clojure-first.core=> 
(defn generate-word-list
  [alphabet word n]
  (let [first-letter (get word 0)]) ;char

  (if (> (count alphabet) 0)
    (concat (str (first alphabet) word)
            (generate-word-list (rest alphabet) word (dec n)))
    (list))    ;then: взять words с n-1  и прибавить буковки слева справа
  list    ;else
  )
#'clojure-first.core/generate-word-list
clj::clojure-first.core=> 
(generate-word-list '(\f \s) "s" 1)
#object[clojure.lang.PersistentList$Primordial 0x6e134c9 "clojure.lang.PersistentList$Primordial@6e134c9"]
clj::clojure-first.core=> (defn generate-word-list
                            [alphabet word n]
                            (let [first-letter (get word 0)]) ;char

                            (if (> (count alphabet) 0)
                              (concat (str (first alphabet) word)
                                      (generate-word-list (rest alphabet) word (dec n))) ;then: взять words с n-1  и прибавить буковки слева справа
                              (list)))
#'clojure-first.core/generate-word-list
clj::clojure-first.core=> 
(generate-word-list '(\f \s) "t" 1)
(\f \s \s \s)
clj::clojure-first.core=> (generate-word-list '(\f \s) "t" 1)
(\f \t \s \t)
clj::clojure-first.core=> 
(generate-word-list '("f" "s") "t" 1)
(\f \t \s \t)
clj::clojure-first.core=> 
(generate-word-list '("f" "s") "ta" 1)
(\f \t \a \s \t \a)
clj::clojure-first.core=> 
(defn generate-word-list
  [alphabet word n]
  (let [first-letter (get word 0)]) ;char

  (if (> (count alphabet) 0)
    (cons (str (first alphabet) word)
          (generate-word-list (rest alphabet) word n))
    (list)))
#'clojure-first.core/generate-word-list
clj::clojure-first.core=> 
(generate-word-list '("f" "s") "ta" 1)
("fta" "sta")
clj::clojure-first.core=> 
(main-word-function '(\d \a) 3)
("dd" "ad" "da" "aa")
clj::clojure-first.core=> 
(main-word-function '(\d \a \r \q) 3)
("dd" "ad" "rd" "qd" "da" "aa" "ra" "qa" "dr" "ar" "rr" "qr" "dq" "aq" "rq" "qq")
clj::clojure-first.core=> 
