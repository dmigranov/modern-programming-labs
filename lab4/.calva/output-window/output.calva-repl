; This is the Calva evaluation results output window.
; TIPS: The keyboard shortcut `ctrl+alt+c o` shows and focuses this window
;   when connected to a REPL session.
; Please see https://calva.io/output/ for more info.
; Happy coding! ♥️

; Connecting ...
; Hooking up nREPL sessions...
; Connected session: clj
; TIPS: 
;   - You can edit the contents here. Use it as a REPL if you like.
;   - `alt+enter` evaluates the current top level form.
;   - `ctrl+enter` evaluates the current form.
;   - `alt+up` and `alt+down` traverse up and down the REPL command history
;      when the cursor is after the last contents at the prompt
;   - Clojure lines in stack traces are peekable and clickable.
clj::lab4.core=> 
(to-dnf (negation (disjunction (implication (variable ::x) (variable ::y)) (negation (implication (variable ::y) (variable ::z))))))
(:conj (:conj (:neg (:neg (:var :lab4.core/x))) (:neg (:var :lab4.core/y))) (:disj (:neg (:var :lab4.core/y)) (:neg (:neg (:var :lab4.core/z)))))
clj::lab4.core=> 
(to-dnf (negation (negation (variable ::x))))
(:var :lab4.core/x)
clj::lab4.core=> 
(to-dnf (implication (negation (negation (variable ::x))) (negation (negation (variable ::x)))))
(:disj (:neg (:var :lab4.core/x)) (:var :lab4.core/x))
clj::lab4.core=> 
(to-dnf (negation (disjunction (implication (variable ::x) (variable ::y)) (negation (implication (variable ::y) (variable ::z))))))
(:conj (:conj (:neg (:neg (:var :lab4.core/x))) (:neg (:var :lab4.core/y))) (:disj (:neg (:var :lab4.core/y)) (:neg (:neg (:var :lab4.core/z)))))
clj::lab4.core=> 
(def tier-2-rules (list
                   [(fn [expr] (and (negation? expr) (conjunction? (second expr))))
                    (fn [expr] (let [neg-arg (second expr)] (apply disjunction (->> (args neg-arg)
                                                                                    (map to-dnf-tier-2)
                                                                                    (map (fn [elem] (negation elem)))))))]
                   [(fn [expr] (and (negation? expr) (disjunction? (second expr))))
                    (fn [expr] (let [neg-arg (second expr)] (apply conjunction (->> (args neg-arg)
                                                                                    (map to-dnf-tier-2)
                                                                                    (map (fn [elem] (negation elem)))))))]

                   ;дистрибутивность слева
                   ;(и (или a b) c)
                   [(fn [expr] (and (conjunction? expr) (disjunction? (second expr))))
                    (fn [expr] (let [conj-args (args expr), disj (first conj-args), disj-args (args disj)
                                     a (first disj-args), b (second disj-args), c (second conj-args)]
                                 (to-dnf-tier-2 (disjunction (conjunction a c) (conjunction b c)))))]

                   ;дистрибутивность справа
                   ;(и c (или a b))
                   [(fn [expr] (and (conjunction? expr) (disjunction? (nth expr 2))))
                    (fn [expr] (let [conj-args (args expr), disj (second conj-args), disj-args (args disj)
                                     a (first disj-args), b (second disj-args), c (first conj-args)]
                                 (println "here")
                                 (to-dnf-tier-2 (disjunction (conjunction c a) (conjunction c b)))))]

                   [(fn [expr] (and (negation? expr) (negation? (second expr))))
                    (fn [expr] (let [arg (first (args (second expr)))] (to-dnf-tier-2 arg)))]
                   [(fn [expr] (conjunction? expr))
                    (fn [expr] (let [e-args (args expr)] (apply conjunction (map to-dnf-tier-2 e-args))))]
                   [(fn [expr] (disjunction? expr))
                    (fn [expr] (let [e-args (args expr)] (apply disjunction (map to-dnf-tier-2 e-args))))]
                   [(fn [expr] (negation? expr))
                    (fn [expr] (let [arg (second expr)] (negation (to-dnf-tier-2 arg))))]
                   [(fn [expr] (or (variable? expr) (log-true? expr) (log-false? expr)))
                    (fn [expr] expr)]))
#'lab4.core/tier-2-rules
clj::lab4.core=> 
(to-dnf (negation (disjunction (implication (variable ::x) (variable ::y)) (negation (implication (variable ::y) (variable ::z))))))
(:conj (:conj (:neg (:neg (:var :lab4.core/x))) (:neg (:var :lab4.core/y))) (:disj (:neg (:var :lab4.core/y)) (:neg (:neg (:var :lab4.core/z)))))
clj::lab4.core=> 
