; This is the Calva evaluation results output window.
; TIPS: The keyboard shortcut `ctrl+alt+c o` shows and focuses this window
;   when connected to a REPL session.
; Please see https://calva.io/output/ for more info.
; Happy coding! ♥️

; Connecting ...
; Hooking up nREPL sessions...
; Connected session: clj
; TIPS: 
;   - You can edit the contents here. Use it as a REPL if you like.
;   - `alt+enter` evaluates the current top level form.
;   - `ctrl+enter` evaluates the current form.
;   - `alt+up` and `alt+down` traverse up and down the REPL command history
;      when the cursor is after the last contents at the prompt
;   - Clojure lines in stack traces are peekable and clickable.
clj::lab4.core=> 
(to-dnf (disjunction (variable ::x) log-false))
(:var :lab4.core/x)
; Execution error (NullPointerException) at lab4.core/fn$fn (core.clj:225).
; null
clj::lab4.core=> 
(to-dnf (disjunction (variable ::x) log-true
                     ))
(:var :lab4.core/x)
; Execution error (NullPointerException) at lab4.core/fn$fn (core.clj:225).
; null
clj::lab4.core=> 
(to-dnf (disjunction (variable ::x) log-true))
(:var :lab4.core/x)
; Execution error (NullPointerException) at lab4.core/fn$fn (core.clj:225).
; null
clj::lab4.core=> 
(def tier-constants-rules (list
                           [(fn [expr] (and (disjunction? expr) (some (fn [elem]
                                                                        (or (constant? elem) (and (negation? elem) (constant? (second elem)))))
                                                                      (args expr))))
                            (fn [expr] (let [const (some (fn [elem] (if (or (constant? elem) (and (negation? elem) (constant? (second elem))))
                                                                      elem
                                                                      nil))
                                                         (args expr))]
                                         (if (or
                                              (= const log-true)
                                              (= const (negation log-false)))
                                           log-true ;тогда выражение истина
                                           () ;иначе можно выкинуть todo
                                           )))]


                           [(fn [expr] (and (conjunction? expr) (some (fn [elem]
                                                                        (or (constant? elem) (and (negation? elem) (constant? (second elem)))))
                                                                      (args expr))))
                            (fn [expr]
                              ;todo
                              )]))
#'lab4.core/tier-constants-rules
clj::lab4.core=> 
(to-dnf (disjunction (variable ::x) log-true))
(:true)
clj::lab4.core=> 
(def tier-constants-rules (list
                           [(fn [expr] (and (disjunction? expr) (some (fn [elem]
                                                                        (or (constant? elem) (and (negation? elem) (constant? (second elem)))))
                                                                      (args expr))))
                            (fn [expr] (let [const (some (fn [elem] (if (or (constant? elem) (and (negation? elem) (constant? (second elem))))
                                                                      elem
                                                                      nil))
                                                         (args expr))]
                                         (println const)
                                         (if (or
                                              (= const log-true)
                                              (= const (negation log-false)))
                                           log-true ;тогда выражение истина
                                           () ;иначе можно выкинуть todo
                                           )))]


                           [(fn [expr] (and (conjunction? expr) (some (fn [elem]
                                                                        (or (constant? elem) (and (negation? elem) (constant? (second elem)))))
                                                                      (args expr))))
                            (fn [expr]
                              ;todo
                              )]))
#'lab4.core/tier-constants-rules
clj::lab4.core=> 
(to-dnf (disjunction (variable ::x) log-true))
(:true)
(:true)
clj::lab4.core=> 
(to-dnf (disjunction (variable ::x) (negation log-false)))
; Execution error (NullPointerException) at lab4.core/to-dnf-tier (core.clj:253).
; null
clj::lab4.core=> 
(negation log-false)
(:neg (:false))
clj::lab4.core=> 
(disjunction (variable ::x) (negation log-false))
(:disj (:var :lab4.core/x) (:neg (:false)))
clj::lab4.core=> 
(to-dnf-tier-1 (disjunction (variable ::x) (negation log-false)))
(:disj (:var :lab4.core/x) (:neg (:false)))
clj::lab4.core=> 
(to-dnf-tier-2 (disjunction (variable ::x) (negation log-false)))
(:disj (:var :lab4.core/x) (:neg (:false)))
clj::lab4.core=> 
(to-dnf-tier-3 (disjunction (variable ::x) (negation log-false)))
(:disj (:var :lab4.core/x) (:neg (:false)))
clj::lab4.core=> 
(to-dnf-tier-unite (disjunction (variable ::x) (negation log-false)))
(:disj (:var :lab4.core/x) (:neg (:false)))
clj::lab4.core=> 
(to-dnf-tier-sort (disjunction (variable ::x) (negation log-false)))
; Execution error (NullPointerException) at lab4.core/to-dnf-tier (core.clj:253).
; null
clj::lab4.core=> 
(to-dnf-tier-sort (conjunction (variable ::x) (negation log-false)))
(:conj (:neg (:false)) (:var :lab4.core/x))
clj::lab4.core=> 
(to-dnf-tier-sort (disjunction (variable ::x) (negation log-false)))
; Execution error (NullPointerException) at lab4.core/to-dnf-tier (core.clj:253).
; null
clj::lab4.core=> 
(declare to-dnf-tier-sort)
(def tier-sort-rules (list
                      [(fn [expr] (conjunction? expr))
                       (fn [expr] (let [c-args (args expr)]
                                    (apply conjunction-internal (sort (fn [x y]
                                                                        (let [a (unnegate-variable-or-constant x) b (unnegate-variable-or-constant y)
                                                                              comp-fn (fn [elem]
                                                                                        (if (variable? elem)
                                                                                          (variable-name elem)
                                                                                          :0))]
                                                                          (compare (comp-fn a) (comp-fn b)))) c-args))))]

                      [(fn [expr] (disjunction? expr))
                       (fn [expr] (let [e-args (args expr)]
                                    (println e-args)
                                    (apply disjunction-internal (map to-dnf-tier-sort e-args))))]

                      [(fn [expr] (or (atomic-expression? expr) (constant? expr)))
                       (fn [expr] expr)]))
#'lab4.core/tier-sort-rules
clj::lab4.core=> 
(to-dnf-tier-sort (disjunction (variable ::x) (negation log-false)))
((:var :lab4.core/x) (:neg (:false)))
; Execution error (NullPointerException) at lab4.core/to-dnf-tier (core.clj:253).
; null
clj::lab4.core=> 
(def tier-sort-rules (list
                      [(fn [expr] (conjunction? expr))
                       (fn [expr] (let [c-args (args expr)]
                                    (apply conjunction-internal (sort (fn [x y]
                                                                        (let [a (unnegate-variable-or-constant x) b (unnegate-variable-or-constant y)
                                                                              comp-fn (fn [elem]
                                                                                        (if (variable? elem)
                                                                                          (variable-name elem)
                                                                                          :0))]
                                                                          (compare (comp-fn a) (comp-fn b)))) c-args))))]

                      [(fn [expr] (disjunction? expr))
                       (fn [expr] (let [e-args (args expr)]
                                    (println e-args)
                                    (apply disjunction-internal (map to-dnf-tier-sort e-args))))]

                      [(fn [expr] (and (negation? expr) (constant? (second expr))))
                       (fn [expr] (if (= (second expr) log-true)
                                    log-false
                                    log-true))]

                      [(fn [expr] (or (atomic-expression? expr) (constant? expr)))
                       (fn [expr] expr)]))
#'lab4.core/tier-sort-rules
clj::lab4.core=> 
(to-dnf-tier-sort (disjunction (variable ::x) (negation log-false)))
((:var :lab4.core/x) (:neg (:false)))
(:disj (:var :lab4.core/x) (:true))
clj::lab4.core=> 
(to-dnf-tier-sort (disjunction (variable ::x) (negation log-false)))
((:var :lab4.core/x) (:neg (:false)))
(:disj (:var :lab4.core/x) (:true))
clj::lab4.core=> 
; nREPL Connection was closed
